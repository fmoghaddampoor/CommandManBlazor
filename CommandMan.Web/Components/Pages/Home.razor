@page "/"
@using CommandMan.Web.Services
@using CommandMan.Web.Components
@using CommandMan.Core.Entities
@using CommandMan.Core.Interfaces
@inject AppState AppState
@inject ProgressService ProgressState
@inject IJSRuntime JS
@inject IFileSystemService FileService
@inject Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage.ProtectedLocalStorage LocalStorage
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>CommandMan</PageTitle>

<div class="main-container">
    <ProgressOverlay />
    <!-- Optional Top Toolbar or Menu could go here -->
    
    <div class="panels-container">
        <div class="file-panel @(AppState.ActivePanel == AppState.LeftPanel ? "active" : "")" 
             @onclick="() => Activate(AppState.LeftPanel)">
            <DrivePicker OnDriveSelected="@(path => SetPanelPath(AppState.LeftPanel, path))" />
            <FilePanel State="@AppState.LeftPanel" 
                       IsActive="@(AppState.ActivePanel == AppState.LeftPanel)" 
                       OnActivate="@(() => Activate(AppState.LeftPanel))"
                       OnDropReceived="@(src => HandleDragMove(src, AppState.LeftPanel))" />
        </div>
        
        <div class="file-panel @(AppState.ActivePanel == AppState.RightPanel ? "active" : "")" 
             @onclick="() => Activate(AppState.RightPanel)">
            <DrivePicker OnDriveSelected="@(path => SetPanelPath(AppState.RightPanel, path))" />
            <FilePanel State="@AppState.RightPanel" 
                       IsActive="@(AppState.ActivePanel == AppState.RightPanel)" 
                       OnActivate="@(() => Activate(AppState.RightPanel))"
                       OnDropReceived="@(src => HandleDragMove(src, AppState.RightPanel))" />
        </div>
    </div>
    
    <div class="command-bar">
        <span class="cmd-prefix">@AppState.ActivePanel.CurrentPath&gt;</span>
        <input type="text" class="cmd-input" />
    </div>
    
    <div class="app-footer" style="z-index: 1000;">
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.View)">F3 View</div>
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.Edit)">F4 Edit</div>
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.Copy)">F5 Copy</div>
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.Move)">F6 Move</div>
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.MkDir)">F7 MkDir</div>
        <div class="f-key-btn" @onclick="() => TriggerAction(ActionType.Delete)">F8 Delete</div>
    </div>
</div>

@if (IsModalVisible)
{
    <div class="modal-overlay">
        <div class="modal-box">
             <div class="modal-title">@ModalTitle</div>
             @if (ModalAction != ActionType.Delete) 
             {
                 <input @bind="ModalInputValue" id="modalInput" autofocus />
             }
             else
             {
                 <p style="color:black">Are you sure you want to delete @AppState.ActivePanel.SelectedItem?.Name ?</p>
             }
             <div class="modal-buttons">
                 <button @onclick="SubmitModal">OK</button>
                 <button @onclick="CloseModal">Cancel</button>
             </div>
        </div>
    </div>
}

@code {
    private DotNetObjectReference<Home>? dotNetHelper;
    
    // Modal State
    private bool IsModalVisible = false;
    private string ModalTitle = "";
    private string ModalInputValue = "";
    private ActionType ModalAction;
    
    private bool isLeftDragOver = false;
    private bool isRightDragOver = false;
    private int leftDragCounter = 0;
    private int rightDragCounter = 0;

    private enum ActionType { None, View, Edit, MkDir, Copy, Move, Delete }

    protected override void OnInitialized()
    {
        AppState.OnChange += StateHasChanged;
        
        // Trigger UI update and auto-save on panel changes
        AppState.LeftPanel.OnChange += async () => { 
            StateHasChanged(); 
            await SavePanelPath(AppState.LeftPanel, "LeftPanelPath");
        };
        AppState.RightPanel.OnChange += async () => { 
            StateHasChanged(); 
            await SavePanelPath(AppState.RightPanel, "RightPanelPath");
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                dotNetHelper = DotNetObjectReference.Create(this);
                try { await JS.InvokeVoidAsync("registerKeyboardHandler", dotNetHelper); } catch {}
                
                // Load state or Defaults
                await LoadState();
            }
            if (IsModalVisible)
            {
                 // Try to focus input
                 try { await JS.InvokeVoidAsync("eval", "document.getElementById('modalInput')?.focus()"); } catch {}
            }
        }
        catch 
        {
            // Logging removed
        }
    }
    
    private async Task LoadState()
    {
        string leftPath = "";
        string rightPath = "";

        // Check query parameters first
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
        
        if (query.TryGetValue("left", out var leftQuery)) leftPath = leftQuery.ToString();
        if (query.TryGetValue("right", out var rightQuery)) rightPath = rightQuery.ToString();

        try 
        {
            if (string.IsNullOrEmpty(leftPath))
            {
                leftPath = await JS.InvokeAsync<string>("loadPanelPath", "LeftPanelPath");
            }
            
            if (string.IsNullOrEmpty(rightPath))
            {
                rightPath = await JS.InvokeAsync<string>("loadPanelPath", "RightPanelPath");
            }
        }
        catch (Exception ex)
        { 
            Console.WriteLine($"LoadState Error: {ex.Message}");
        } 

        // Get default drive for fallback
        var drives = await FileService.GetDrivesAsync();
        var defaultDrive = drives.FirstOrDefault()?.FullPath ?? "C:\\";

        // Validate left path exists, fallback to default drive if not
        if (string.IsNullOrEmpty(leftPath) || !await FileService.ExistsAsync(leftPath))
        {
            leftPath = defaultDrive;
        }

        // Validate right path exists, fallback to default drive if not
        if (string.IsNullOrEmpty(rightPath) || !await FileService.ExistsAsync(rightPath))
        {
            rightPath = defaultDrive;
        }

        Console.WriteLine($"Applying Paths: Left={leftPath}, Right={rightPath}");

        // Apply
        await SetPanelPath(AppState.LeftPanel, leftPath, save: false);
        await SetPanelPath(AppState.RightPanel, rightPath, save: false);
        StateHasChanged();
    }
    
    private async Task SetPanelPath(PanelState panel, string path, bool save = true)
    {
        panel.CurrentPath = path;
        panel.Items = await FileService.GetDirectoryContentAsync(path);
        // Select first item if possible? No, keep selection null or default
        panel.SelectedItem = panel.Items.FirstOrDefault(); // Optional: select first
        panel.NotifyStateChanged();
        
        // Saving is now handled by the OnChange event subscription in OnInitialized
    }

    private async Task SavePanelPath(PanelState panel, string key)
    {
        try
        {
            if (!string.IsNullOrEmpty(panel.CurrentPath))
            {
               await JS.InvokeVoidAsync("savePanelPath", key, panel.CurrentPath);
            }
        }
        catch (Exception ex)
        {
             // Console.WriteLine($"Error saving path for {key}: {ex.Message}");
        }
    }

    private void Activate(PanelState panel)
    {
        AppState.SetActivePanel(panel);
    }

    public class KeyEventArgs {
        public string Key { get; set; } = "";
        public bool ShiftKey { get; set; }
        public bool CtrlKey { get; set; }
        public bool AltKey { get; set; }
    }

    [JSInvokable]
    public async Task HandleKeyDown(KeyEventArgs e)
    {
        if (IsModalVisible)
        {
            if (e.Key == "Enter") await SubmitModal();
            return;
        }

        switch (e.Key)
        {
            case "ArrowUp":
                AppState.ActivePanel.MoveSelection(-1, range: e.ShiftKey);
                break;
            case "ArrowDown":
                AppState.ActivePanel.MoveSelection(1, range: e.ShiftKey);
                break;
            case "Tab":
                if (AppState.ActivePanel == AppState.LeftPanel)
                    AppState.SetActivePanel(AppState.RightPanel);
                else
                    AppState.SetActivePanel(AppState.LeftPanel);
                break;
            case "Enter":
                await HandleEnter();
                break;
            case "F3":
                await TriggerAction(ActionType.View);
                break;
            case "F4":
                await TriggerAction(ActionType.Edit);
                break;
            case "F5":
                await TriggerAction(ActionType.Copy);
                break;
            case "F6":
                await TriggerAction(ActionType.Move);
                break;
            case "F7":
                await TriggerAction(ActionType.MkDir);
                break;
            case "F8":
                await TriggerAction(ActionType.Delete);
                break;
        }
    }

    private async Task TriggerAction(ActionType action)
    {
        var passive = AppState.ActivePanel == AppState.LeftPanel ? AppState.RightPanel : AppState.LeftPanel;
        
        switch (action)
        {
            case ActionType.View:
                // TODO: Implement View
                break;
            case ActionType.Edit:
                await HandleEdit();
                break;
            case ActionType.Copy:
            case ActionType.Move:
                // Automate: Destination is always the other panel
                ModalAction = action;
                ModalInputValue = passive.CurrentPath;
                await SubmitModal();
                break;
            case ActionType.MkDir:
            case ActionType.Delete:
                OpenModal(action);
                break;
        }
    }


    private async Task HandleEdit()
    {
        var item = AppState.ActivePanel.SelectedItem;
        if (item is FileItem)
        {
            await FileService.OpenFileAsync(item.FullPath);
        }
    }
    
    private void OpenModal(ActionType action)
    {
        ModalAction = action;
        IsModalVisible = true;
        
        var passive = AppState.ActivePanel == AppState.LeftPanel ? AppState.RightPanel : AppState.LeftPanel;
        var selectedCount = AppState.ActivePanel.SelectedItems.Count;
        var selectedName = selectedCount > 1 ? $"{selectedCount} items" : (AppState.ActivePanel.SelectedItem?.Name ?? "");

        switch (action)
        {
            case ActionType.MkDir:
                ModalTitle = "Create Directory";
                ModalInputValue = "";
                break;
            case ActionType.Copy:
                ModalTitle = "Copy " + selectedName + " to:";
                ModalInputValue = passive.CurrentPath; // Default to target panel
                break;
            case ActionType.Move:
                ModalTitle = "Move " + selectedName + " to:";
                ModalInputValue = passive.CurrentPath;
                break;
            case ActionType.Delete:
                ModalTitle = "Delete " + selectedName;
                break;
        }
        StateHasChanged();
    }
    
    private void CloseModal()
    {
        IsModalVisible = false;
        StateHasChanged();
    }

    private async Task SubmitModal()
    {
        Console.WriteLine($"SubmitModal: {ModalAction} to {ModalInputValue}");
        try 
        {
            var active = AppState.ActivePanel;
            var targetPanel = active == AppState.LeftPanel ? AppState.RightPanel : AppState.LeftPanel;
            var selectedItems = active.SelectedItems.ToList();
            
            // Add current focused item if not in selection
            if (active.SelectedItem != null && !selectedItems.Contains(active.SelectedItem))
            {
                selectedItems.Add(active.SelectedItem);
            }

            if (selectedItems.Count == 0 && ModalAction != ActionType.MkDir)
            {
                CloseModal();
                return;
            }

            CloseModal();

            switch (ModalAction)
            {
                case ActionType.MkDir:
                    if (!string.IsNullOrWhiteSpace(ModalInputValue))
                    {
                        var newPath = System.IO.Path.Combine(active.CurrentPath, ModalInputValue);
                        await FileService.CreateDirectoryAsync(newPath);
                        await ReloadPanel(active);
                        
                        // Select the new folder
                        var newItem = active.Items.FirstOrDefault(i => i.Name.Equals(ModalInputValue, StringComparison.OrdinalIgnoreCase));
                        if (newItem != null) active.SelectItem(newItem);
                    }
                    break;

                case ActionType.Copy:
                case ActionType.Move:
                    ProgressState.Start(ModalAction == ActionType.Copy ? "Copying..." : "Moving...");
                    int idx = 0;
                    var transferredNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    
                    foreach (var item in selectedItems)
                    {
                        idx++;
                        var progressValue = (double)idx / selectedItems.Count * 100;
                        ProgressState.Update(progressValue, $"Processing: {item.Name}");
                        
                        var dest = System.IO.Path.Combine(ModalInputValue, item.Name);
                        
                        if (ModalAction == ActionType.Copy)
                            await FileService.CopyItemAsync(item.FullPath, dest);
                        else
                            await FileService.MoveItemAsync(item.FullPath, dest);
                        
                        transferredNames.Add(item.Name);
                    }
                    ProgressState.Stop();
                    await ReloadPanel(active);
                    await ReloadPanel(targetPanel);

                    // Select transferred items in target panel
                    if (transferredNames.Any())
                    {
                        var newItems = targetPanel.Items.Where(i => transferredNames.Contains(i.Name)).ToList();
                        if (newItems.Any())
                        {
                            targetPanel.SelectedItems.Clear();
                            foreach (var ni in newItems) targetPanel.SelectedItems.Add(ni);
                            targetPanel.SelectedItem = newItems.First();
                            targetPanel.NotifyStateChanged();
                            
                            // Also activate the target panel so user sees the result
                            AppState.SetActivePanel(targetPanel);
                        }
                    }
                    break;

                case ActionType.Delete:
                    ProgressState.Start("Deleting...");
                    int dIdx = 0;
                    foreach (var item in selectedItems)
                    {
                        dIdx++;
                        var progressValue = (double)dIdx / selectedItems.Count * 100;
                        ProgressState.Update(progressValue, $"Deleting: {item.Name}");
                        await FileService.DeleteItemAsync(item.FullPath);
                    }
                    ProgressState.Stop();
                    await ReloadPanel(active);
                    break;
            }
        }
        catch (Exception ex)
        {
            ProgressState.Stop();
            Console.WriteLine($"Error: {ex.Message}");
        }
    }

    private async Task ReloadPanel(PanelState panel)
    {
        panel.Items = await FileService.GetDirectoryContentAsync(panel.CurrentPath);
        panel.NotifyStateChanged();
    }

    private async Task HandleEnter()
    {
        var item = AppState.ActivePanel.SelectedItem;
        if (item is DirectoryItem dir)
        {
            AppState.ActivePanel.CurrentPath = dir.FullPath;
             AppState.ActivePanel.Items = await FileService.GetDirectoryContentAsync(AppState.ActivePanel.CurrentPath);
             AppState.ActivePanel.SelectedItem = null; // Reset selection
             AppState.ActivePanel.NotifyStateChanged();
        }
    }

    private async Task HandleMkDir()
    {
        // Replaced by Modal
    }

    private async Task HandleDelete()
    {
         // Replaced by Modal
    }

    public async ValueTask DisposeAsync()
    {
        AppState.OnChange -= StateHasChanged;
        AppState.LeftPanel.OnChange -= StateHasChanged;
        AppState.RightPanel.OnChange -= StateHasChanged;
        if (dotNetHelper != null)
        {
            try 
            {
                await JS.InvokeVoidAsync("unregisterKeyboardHandler");
            } 
            catch {} 
            dotNetHelper.Dispose();
        }
    }

    private async Task HandleDragMove(PanelState source, PanelState target)
    {
        await Log($"HandleDragMove from {source.CurrentPath} to {target.CurrentPath}");
        if (source == target) return;

        AppState.SetActivePanel(source);
        ModalAction = ActionType.Move;
        ModalInputValue = target.CurrentPath;
        await SubmitModal();
    }

    private async Task Log(string msg)
    {
        try { await JS.InvokeVoidAsync("console.log", "[D&D Debug] " + msg); } catch {}
    }
}


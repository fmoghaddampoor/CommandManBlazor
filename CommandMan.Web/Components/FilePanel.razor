@using CommandMan.Core.Entities
@using CommandMan.Core.Interfaces
@using CommandMan.Web.Services
@inject IFileSystemService FileService
@inject FavoritesService FavoritesService
@inject IJSRuntime JSRuntime

<div class="file-list-container @(isDragOver ? "drag-over" : "")" 
     id="@panelId"
     @onclick="ActivatePanel"
     @ref="panelContainer">
    <div class="panel-header">
        <span class="current-path">@State.CurrentPath</span>
        <div class="header-buttons">
            <button class="header-btn heart-btn" title="Add Favorite" @onclick="AddFavorite">
                <i class="fas fa-heart"></i>
            </button>
            <button class="header-btn list-btn" title="Favorites" @onclick="ToggleFavorites">
                <i class="fas fa-list-ul"></i>
            </button>
            @if (showFavorites)
            {
                <div class="favorites-menu">
                    @if (FavoritesService.GetFavorites().Any())
                    {
                        @foreach (var fav in FavoritesService.GetFavorites())
                        {
                            <div class="menu-item" @onclick="() => LoadFavorite(fav.Path)">
                                <i class="fas fa-star text-warning" style="margin-right:8px;"></i>
                                <span>@fav.Name</span>
                            </div>
                        }
                    }
                    else
                    {
                        <div class="menu-item disabled">No favorites yet</div>
                    }
                </div>
            }
        </div>
    </div>
    <div class="file-list" id="@($"fileList_{State.GetHashCode()}")">
        <table class="table table-sm table-hover file-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Ext</th>
                    <th>Size</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                @if (State.CurrentPath != ParemptPath && !string.IsNullOrEmpty(State.CurrentPath))
                {
                     <tr @ondblclick="GoUp">
                        <td><i class="fas fa-level-up-alt" style="margin-right:8px; color: var(--accent-color);"></i> [..]</td>
                        <td></td>
                        <td>&lt;DIR&gt;</td>
                        <td></td>
                    </tr>
                }
                @foreach (var item in State.Items)
                {
                    <tr class="@(State.SelectedItems.Contains(item) ? "selected" : "")" 
                        draggable="true"
                        @ondragstart="() => HandleDragStart(item)"
                        @onclick="(e) => SelectItem(e, item)"
                        @ondblclick="() => OpenItem(item)">
                        <td>
                            <i class="@GetIconClass(item)" style="margin-right:8px;"></i>
                            @if (item is DirectoryItem)
                            {
                                <span>[@item.Name]</span>
                            }
                            else
                            {
                                <span>@item.Name</span>
                            }
                        </td>
                        <td>@item.Extension</td>
                        <td>@(item is FileItem f ? FormatSize(f.FileSize) : "<DIR>")</td>
                        <td>@item.LastModified.ToString("yyyy-MM-dd HH:mm")</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div class="panel-footer">
        <span>@State.Items.Count items</span>
        <span class="selected-count">@State.SelectedItems.Count selected</span>
    </div>
</div>

@code {
    [Parameter] public PanelState State { get; set; } = null!;
    [Parameter] public bool IsActive { get; set; }
    [Parameter] public EventCallback OnActivate { get; set; }
    [Parameter] public EventCallback<PanelState> OnDropReceived { get; set; }

    private bool isDragOver = false;
    private int dragCounter = 0;
    private bool showFavorites = false;
    private ElementReference panelContainer;
    private DotNetObjectReference<FilePanel>? dotNetRef;
    private string panelId => $"panel_{State.GetHashCode()}";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupDragDrop", dotNetRef, panelId);
        }

        // Auto-scroll to selected item
        if (State.SelectedItem != null && IsActive)
        {
            try {
                await Task.Delay(1); 
                var selector = $".file-panel.active #fileList_{State.GetHashCode()} .selected";
                await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('{selector}')?.scrollIntoView({{block:'nearest'}})");
            } catch {}
        }
    }

    [JSInvokable]
    public async Task OnDropFromJS()
    {
        try { await JSRuntime.InvokeVoidAsync("console.log", "[D&D Debug] C#: OnDropFromJS invoked for " + State.CurrentPath); } catch {}
        isDragOver = false;
        dragCounter = 0;
        if (DragDropService.SourcePanel != null && DragDropService.SourcePanel != State)
        {
            await OnDropReceived.InvokeAsync(DragDropService.SourcePanel);
        }
        DragDropService.SourcePanel = null;
        StateHasChanged();
    }

    private string ParemptPath => ""; // simplified

    protected override async Task OnInitializedAsync()
    {
        if (string.IsNullOrEmpty(State.CurrentPath))
        {
             // Default start
             State.CurrentPath = ""; // Root drives
        }
        await LoadData();
    }

    private async Task LoadData()
    {
        State.Items = await FileService.GetDirectoryContentAsync(State.CurrentPath);
        State.NotifyStateChanged();
    }

    private async Task OpenItem(FileSystemItem item)
    {
        if (item is DirectoryItem dir)
        {
            State.CurrentPath = dir.FullPath;
            await LoadData();
        }
        // TODO: Handle file execution
    }

    private async Task GoUp()
    {
        var parent = FileService.GetParentPath(State.CurrentPath);
         // If parent is empty but current path was not empty, it means we go to drives.
         // If current path is root drive (e.g. C:\), GetParent might handle it or we set to empty.
         if (string.IsNullOrEmpty(parent) && !string.IsNullOrEmpty(State.CurrentPath))
         {
             // Check if we are at drive root, if so go to empty (drives list)
             // Simplified logic for now: IFileSystemService GetParentPath should handle logic, 
             // but let's assume empty string is root of roots.
             State.CurrentPath = "";
         }
         else
         {
             State.CurrentPath = parent;
         }
         await LoadData();
    }

    private void SelectItem(MouseEventArgs e, FileSystemItem item)
    {
        State.SelectItem(item, toggle: e.CtrlKey, range: e.ShiftKey);
        ActivatePanel(); 
    }

    private void HandleDragStart(FileSystemItem item)
    {
        try { JSRuntime.InvokeVoidAsync("console.log", "[D&D Debug] Drag Start: " + item.Name); } catch {}
        if (!State.SelectedItems.Contains(item))
        {
            State.SelectItem(item);
        }
        DragDropService.SourcePanel = State;
    }
    
    private void ActivatePanel()
    {
        if (!IsActive)
        {
            OnActivate.InvokeAsync();
        }
    }

    private void AddFavorite()
    {
        ActivatePanel();
        JSRuntime.InvokeVoidAsync("openAddFavoriteModal");
    }

    private void ToggleFavorites()
    {
        showFavorites = !showFavorites;
    }

    private async Task LoadFavorite(string path)
    {
        showFavorites = false;
        State.CurrentPath = path;
        await LoadData();
        ActivatePanel();
    }

    private string FormatSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private string GetIconClass(FileSystemItem item)
    {
        if (item is DirectoryItem) return "fas fa-folder text-warning"; // text-warning is usually yellow/gold if bootstrap, else we need style or custom class
        // Use inline style or custom color for now if text-warning isn't defined in my new css.
        // Wait, my new css doesn't define text-warning. I should use specific colors or "fas fa-folder" with inline style in markup?
        // Let's return class and I'll add style in markup or here.
        // Actually, let's just use "fas fa-folder" and assume I add color in markup or CSS.
        // Or I can return "fas fa-folder" and the markup has style.
        
        string ext = item.Extension.ToLower();
        return ext switch
        {
            ".exe" => "fas fa-window-maximize",
            ".dll" => "fas fa-cogs",
            ".txt" => "fas fa-file-alt",
            ".pdf" => "fas fa-file-pdf",
            ".jpg" or ".png" or ".gif" => "fas fa-file-image",
            ".zip" or ".rar" or ".7z" => "fas fa-file-archive",
            ".cs" or ".js" or ".html" or ".css" => "fas fa-file-code",
            _ => "fas fa-file"
        };
    }
    
    // Auto-scroll is now handled in the main OnAfterRenderAsync above
}

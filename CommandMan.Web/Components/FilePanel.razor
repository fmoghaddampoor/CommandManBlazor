@using CommandMan.Core.Entities
@using CommandMan.Core.Interfaces
@using CommandMan.Web.Services
@inject IFileSystemService FileService
@inject IJSRuntime JSRuntime

<div class="file-panel @(IsActive ? "active" : "")" @onclick="ActivatePanel">
    <div class="panel-header">
        <span class="current-path">@State.CurrentPath</span>
    </div>
    <div class="file-list" id="@($"fileList_{State.GetHashCode()}")">
        <table class="table table-sm table-hover file-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Ext</th>
                    <th>Size</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                @if (State.CurrentPath != ParemptPath && !string.IsNullOrEmpty(State.CurrentPath))
                {
                     <tr @ondblclick="GoUp">
                        <td><i class="fas fa-level-up-alt" style="margin-right:8px; color: var(--accent-color);"></i> [..]</td>
                        <td></td>
                        <td>&lt;DIR&gt;</td>
                        <td></td>
                    </tr>
                }
                @foreach (var item in State.Items)
                {
                    <tr class="@(item == State.SelectedItem ? "selected" : "")" 
                        @onclick="() => SelectItem(item)"
                        @ondblclick="() => OpenItem(item)">
                        <td>
                            <i class="@GetIconClass(item)" style="margin-right:8px;"></i>
                            @if (item is DirectoryItem)
                            {
                                <span>[@item.Name]</span>
                            }
                            else
                            {
                                <span>@item.Name</span>
                            }
                        </td>
                        <td>@item.Extension</td>
                        <td>@(item is FileItem f ? FormatSize(f.FileSize) : "<DIR>")</td>
                        <td>@item.LastModified.ToString("yyyy-MM-dd HH:mm")</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div class="panel-footer">
        @State.Items.Count items
    </div>
</div>

@code {
    [Parameter] public PanelState State { get; set; } = null!;
    [Parameter] public bool IsActive { get; set; }
    [Parameter] public EventCallback OnActivate { get; set; }

    private string ParemptPath => ""; // simplified

    protected override async Task OnInitializedAsync()
    {
        if (string.IsNullOrEmpty(State.CurrentPath))
        {
             // Default start
             State.CurrentPath = ""; // Root drives
        }
        await LoadData();
    }

    private async Task LoadData()
    {
        State.Items = await FileService.GetDirectoryContentAsync(State.CurrentPath);
        State.NotifyStateChanged();
    }

    private async Task OpenItem(FileSystemItem item)
    {
        if (item is DirectoryItem dir)
        {
            State.CurrentPath = dir.FullPath;
            await LoadData();
        }
        // TODO: Handle file execution
    }

    private async Task GoUp()
    {
        var parent = FileService.GetParentPath(State.CurrentPath);
         // If parent is empty but current path was not empty, it means we go to drives.
         // If current path is root drive (e.g. C:\), GetParent might handle it or we set to empty.
         if (string.IsNullOrEmpty(parent) && !string.IsNullOrEmpty(State.CurrentPath))
         {
             // Check if we are at drive root, if so go to empty (drives list)
             // Simplified logic for now: IFileSystemService GetParentPath should handle logic, 
             // but let's assume empty string is root of roots.
             State.CurrentPath = "";
         }
         else
         {
             State.CurrentPath = parent;
         }
         await LoadData();
    }

    private void SelectItem(FileSystemItem item)
    {
        State.SelectedItem = item;
        ActivatePanel(); // Converting click to selection also activates
    }
    
    private void ActivatePanel()
    {
        if (!IsActive)
        {
            OnActivate.InvokeAsync();
        }
    }

    private string FormatSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private string GetIconClass(FileSystemItem item)
    {
        if (item is DirectoryItem) return "fas fa-folder text-warning"; // text-warning is usually yellow/gold if bootstrap, else we need style or custom class
        // Use inline style or custom color for now if text-warning isn't defined in my new css.
        // Wait, my new css doesn't define text-warning. I should use specific colors or "fas fa-folder" with inline style in markup?
        // Let's return class and I'll add style in markup or here.
        // Actually, let's just use "fas fa-folder" and assume I add color in markup or CSS.
        // Or I can return "fas fa-folder" and the markup has style.
        
        string ext = item.Extension.ToLower();
        return ext switch
        {
            ".exe" => "fas fa-window-maximize",
            ".dll" => "fas fa-cogs",
            ".txt" => "fas fa-file-alt",
            ".pdf" => "fas fa-file-pdf",
            ".jpg" or ".png" or ".gif" => "fas fa-file-image",
            ".zip" or ".rar" or ".7z" => "fas fa-file-archive",
            ".cs" or ".js" or ".html" or ".css" => "fas fa-file-code",
            _ => "fas fa-file"
        };
    }
    
    // Auto-scroll
    private ElementReference? selectedRow; // We can't bind to a loop variable easily.
    // Instead, let's just trigger loop search in JS or simpler:
    // We already have scrollToSelection in JS. Let's use eval for now but cleaner, or invoke unique ID.
    // Actually, calling querySelector after render is the most robust if we don't have refs.
    // Let's improve the query selector to be super specific.
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
         if (State.SelectedItem != null && IsActive)
         {
             // Use the function we defined in interop.js, but we need the element.
             // Since we don't have the element, we continue to use querySelector via eval or a helper.
             // Helper: window.scrollToSelector = (selector) => ...
             try {
                // Using a small delay can sometimes fix render timing issues
                await Task.Delay(1); 
                var selector = $".file-panel.active #fileList_{State.GetHashCode()} .selected";
                await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('{selector}')?.scrollIntoView({{block:'nearest'}})");
             } catch {}
         }
    }
}

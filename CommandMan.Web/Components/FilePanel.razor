@using CommandMan.Core.Entities
@using CommandMan.Core.Interfaces
@using CommandMan.Web.Services
@inject IFileSystemService FileService
@inject IFavoritesService FavoritesService
@inject IClipboardService ClipboardService
@inject IJSRuntime JSRuntime

<div class="file-list-container @(isDragOver ? "drag-over" : "")" 
     id="@panelId"
     @onclick="ActivatePanel"
     @oncontextmenu:preventDefault
     @oncontextmenu="(e) => ShowBackgroundContextMenu(e)"
     @ref="panelContainer">
    <div class="panel-header">
        @if (isEditingPath)
        {
            <input @ref="pathInputRef" 
                   type="text" 
                   class="path-edit-input" 
                   @bind="tempPath" 
                   @bind:event="oninput"
                   @onkeydown="HandlePathKeyDown"
                   @onblur="CancelEditingPath" />
            <button class="action-btn" style="margin-right: 10px;" title="Go to path" @onclick="SubmitPath" @onmousedown:preventDefault @onmousedown:stopPropagation>
                <i class="fas fa-check"></i>
            </button>
        }
        else
        {
            <span class="current-path" @onclick="StartEditingPath" title="Click to edit path">@State.CurrentPath</span>
        }
        <div class="header-buttons">
            <button class="header-btn sync-btn" title="Load path from other panel" @onclick="LoadPathFromOtherPanel">
                <i class="fas fa-exchange-alt"></i>
            </button>
            <button class="header-btn heart-btn" title="Add Favorite" @onclick="AddFavorite">
                <i class="fas fa-heart"></i>
            </button>
            <button class="header-btn list-btn" title="Favorites" @onclick="ToggleFavorites">
                <i class="fas fa-list-ul"></i>
            </button>
            <button class="header-btn manage-btn" title="Manage Favorites" @onclick="ManageFavorites">
                <i class="fas fa-cog"></i>
            </button>
            @if (showFavorites)
            {
                <div class="favorites-menu">
                    @if (FavoritesService.GetFavorites().Any())
                    {
                        @RenderFavorites(FavoritesService.GetFavorites())
                    }
                    else
                    {
                        <div class="menu-item disabled">No favorites yet</div>
                    }
                </div>
            }
        </div>
    </div>
    <div class="file-list @(State.IsLoading ? "loading" : "")" id="@($"fileList_{State.GetHashCode()}")" @onclick="OnBackgroundClick">
        @if (State.IsLoading)
        {
            <div class="loading-overlay">
                <div class="spinner"></div>
                <span>Loading...</span>
            </div>
        }
        <table class="table table-sm table-hover file-table">
            <thead>
                <tr>
                    <th @onclick='() => State.Sort("Name")' @onclick:stopPropagation class="sortable">Name @(RenderSortIndicator("Name"))</th>
                    <th @onclick='() => State.Sort("Extension")' @onclick:stopPropagation class="sortable">Extension @(RenderSortIndicator("Extension"))</th>
                    <th @onclick='() => State.Sort("Date modified")' @onclick:stopPropagation class="sortable">Date modified @(RenderSortIndicator("Date modified"))</th>
                    <th @onclick='() => State.Sort("Size")' @onclick:stopPropagation class="sortable">Size @(RenderSortIndicator("Size"))</th>
                    <th @onclick='() => State.Sort("File version")' @onclick:stopPropagation class="sortable">File version @(RenderSortIndicator("File version"))</th>
                </tr>
            </thead>
            <tbody>
                @if (State.CurrentPath != ParemptPath && !string.IsNullOrEmpty(State.CurrentPath))
                {
                     <tr @ondblclick="GoUp" @onclick:stopPropagation>
                        <td><i class="fas fa-level-up-alt" style="margin-right:8px; color: var(--accent-color);"></i> [..]</td>
                        <td>&lt;DIR&gt;</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                }
                @for (int i = 0; i < State.Items.Count; i++)
                {
                    var item = State.Items[i];
                    <tr class="@(State.SelectedItems.Contains(item) ? "selected" : "")" 
                        draggable="true"
                        @ondragstart="() => HandleDragStart(item)"
                        @onclick="(e) => SelectItem(e, item)"
                        @onclick:stopPropagation
                        @oncontextmenu="(e) => ShowItemContextMenu(e, item)"
                        @oncontextmenu:preventDefault
                        @oncontextmenu:stopPropagation
                        @ondblclick="() => OpenItem(item)"
                        data-index="@i">
                        <td>
                            <i class="@GetIconClass(item)" style="margin-right:8px;"></i>
                            @if (item is DirectoryItem)
                            {
                                <span>[@item.Name]</span>
                            }
                            else
                            {
                                <span>@item.Name</span>
                            }
                        </td>
                        <td>@item.Extension</td>
                        <td>@item.LastModified.ToString("yyyy-MM-dd HH:mm")</td>
                        <td>@(item is FileItem f ? FormatSize(f.FileSize) : "<DIR>")</td>
                        <td>@item.FileVersion</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div class="panel-footer">
        <span>@State.Items.Count items</span>
        <span class="selected-count">@State.SelectedItems.Count selected</span>
    </div>
</div>

<ContextMenu Visible="@IsContextMenuVisible" 
             X="@ContextMenuX" 
             Y="@ContextMenuY" 
             Items="@ContextMenuItems" 
             OnClose="CloseContextMenu" 
             OnAction="ExecuteMenuAction" />

@code {
    [Parameter] public PanelState State { get; set; } = null!;
    [Parameter] public PanelState? OtherPanelState { get; set; }
    [Parameter] public bool IsActive { get; set; }
    [Parameter] public EventCallback OnActivate { get; set; }
    [Parameter] public EventCallback<PanelState> OnDropReceived { get; set; }
    [Parameter] public EventCallback<string> OnLoadPath { get; set; }

    private bool isDragOver = false;
    private int dragCounter = 0;
    private bool showFavorites = false;
    private bool isEditingPath = false;
    private bool shouldFocusPathInput = false;
    private string tempPath = "";
    private ElementReference pathInputRef;
    private ElementReference panelContainer;
    private DotNetObjectReference<FilePanel>? dotNetRef;
    private string panelId => $"panel_{State.GetHashCode()}";

    // Context Menu State
    private bool IsContextMenuVisible;
    private double ContextMenuX;
    private double ContextMenuY;
    private List<ContextMenu.MenuAction> ContextMenuItems = new();



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupDragDrop", dotNetRef, panelId);
            await JSRuntime.InvokeVoidAsync("setupSelection", dotNetRef, panelId);
        }

        if (shouldFocusPathInput)
        {
            shouldFocusPathInput = false;
            try 
            {
                await JSRuntime.InvokeVoidAsync("selectInputText", pathInputRef);
            }
            catch {}
        }

        // Auto-scroll to selected item
        if (State.SelectedItem != null && IsActive)
        {
            try {
                await Task.Delay(1); 
                var selector = $".file-panel.active #fileList_{State.GetHashCode()} .selected";
                await JSRuntime.InvokeVoidAsync("eval", $"document.querySelector('{selector}')?.scrollIntoView({{block:'nearest'}})");
            } catch {}
        }
    }

    [JSInvokable]
    public async Task OnDropFromJS()
    {
        try { await JSRuntime.InvokeVoidAsync("console.log", "[D&D Debug] C#: OnDropFromJS invoked for " + State.CurrentPath); } catch {}
        isDragOver = false;
        dragCounter = 0;
        if (DragDropService.SourcePanel != null && DragDropService.SourcePanel != State)
        {
            await OnDropReceived.InvokeAsync(DragDropService.SourcePanel);
        }
        DragDropService.SourcePanel = null;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnSelectionChanged(int[] indices, bool append)
    {
        if (!append)
        {
            State.SelectedItems.Clear();
        }

        foreach (var index in indices)
        {
            if (index >= 0 && index < State.Items.Count)
            {
                var item = State.Items[index];
                if (!State.SelectedItems.Contains(item))
                {
                    State.SelectedItems.Add(item);
                }
            }
        }
        StateHasChanged();
    }

    private string ParemptPath => ""; // simplified

    protected override async Task OnInitializedAsync()
    {
        if (string.IsNullOrEmpty(State.CurrentPath))
        {
             // Default start
             State.CurrentPath = ""; // Root drives
        }
        await LoadData();
    }

    private async Task LoadData()
    {
        State.IsLoading = true;
        State.NotifyStateChanged();
        try
        {
            State.Items = await FileService.GetDirectoryContentAsync(State.CurrentPath);
            State.Sort(); // Keep current sort
        }
        finally
        {
            State.IsLoading = false;
            State.NotifyStateChanged();
        }
    }

    private async Task OpenItem(FileSystemItem item)
    {
        if (item is DirectoryItem dir)
        {
            State.CurrentPath = dir.FullPath;
            await LoadData();
        }
        // TODO: Handle file execution
    }

    private async Task GoUp()
    {
        var parent = FileService.GetParentPath(State.CurrentPath);
         // If parent is empty but current path was not empty, it means we go to drives.
         // If current path is root drive (e.g. C:\), GetParent might handle it or we set to empty.
         if (string.IsNullOrEmpty(parent) && !string.IsNullOrEmpty(State.CurrentPath))
         {
             // Check if we are at drive root, if so go to empty (drives list)
             // Simplified logic for now: IFileSystemService GetParentPath should handle logic, 
             // but let's assume empty string is root of roots.
             State.CurrentPath = "";
         }
         else
         {
             State.CurrentPath = parent;
         }
         await LoadData();
    }

    private void SelectItem(MouseEventArgs e, FileSystemItem item)
    {
        State.SelectItem(item, toggle: e.CtrlKey, range: e.ShiftKey);
        ActivatePanel(); 
    }

    private void HandleDragStart(FileSystemItem item)
    {
        try { JSRuntime.InvokeVoidAsync("console.log", "[D&D Debug] Drag Start: " + item.Name); } catch {}
        if (!State.SelectedItems.Contains(item))
        {
            State.SelectItem(item);
        }
        DragDropService.SourcePanel = State;
    }
    
    private void ActivatePanel()
    {
        if (!IsActive)
        {
            OnActivate.InvokeAsync();
        }
    }

    private void AddFavorite()
    {
        ActivatePanel();
        JSRuntime.InvokeVoidAsync("openAddFavoriteModal");
    }

    private async Task LoadPathFromOtherPanel()
    {
        if (OtherPanelState == null || string.IsNullOrEmpty(OtherPanelState.CurrentPath))
        {
            return;
        }
        
        await OnLoadPath.InvokeAsync(OtherPanelState.CurrentPath);
    }

    private void ToggleFavorites()
    {
        showFavorites = !showFavorites;
    }

    private void OnBackgroundClick()
    {
        ActivatePanel(); // Ensure panel is active
        State.SelectedItems.Clear(); // Deselect all
    }

    private void ManageFavorites()
    {
        ActivatePanel();
        JSRuntime.InvokeVoidAsync("openManageFavoritesModal");
    }

    private async Task LoadFavorite(string path)
    {
        showFavorites = false;
        State.CurrentPath = path;
        await LoadData();
        ActivatePanel();
    }

    private Task StartEditingPath()
    {
        tempPath = State.CurrentPath;
        isEditingPath = true;
        shouldFocusPathInput = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void CancelEditingPath()
    {
        isEditingPath = false;
        StateHasChanged();
    }

    private async Task HandlePathKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SubmitPath();
        }
        else if (e.Key == "Escape")
        {
            CancelEditingPath();
        }
    }

    private async Task SubmitPath()
    {
        Console.WriteLine($"SubmitPath: {tempPath}");
        if (string.IsNullOrWhiteSpace(tempPath))
        {
            tempPath = ""; // Root
        }
        else
        {
            // Capitalize drive letter (e.g. c:\ -> C:\)
            if (tempPath.Length >= 2 && char.IsLetter(tempPath[0]) && tempPath[1] == ':')
            {
                tempPath = char.ToUpper(tempPath[0]) + tempPath.Substring(1);
            }

            // Normalize: remove trailing slash except for drive root
            if (tempPath.Length > 3 && (tempPath.EndsWith("\\") || tempPath.EndsWith("/")))
            {
                tempPath = tempPath.Substring(0, tempPath.Length - 1);
            }
            // Add trailing slash for drive root if missing (e.g. C: -> C:\)
            if (tempPath.Length == 2 && char.IsLetter(tempPath[0]) && tempPath[1] == ':')
            {
                tempPath += "\\";
            }
        }

        if (tempPath == State.CurrentPath)
        {
            isEditingPath = false;
            return;
        }

        try 
        {
            bool exists = await FileService.ExistsAsync(tempPath);
            if (exists)
            {
                State.CurrentPath = tempPath;
                await LoadData();
            }
            else
            {
                Console.WriteLine($"Path does not exist: {tempPath}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error validating path: {ex.Message}");
        }
        
        isEditingPath = false;
        StateHasChanged();
    }

    private RenderFragment RenderFavorites(List<FavoriteItem> items) => __builder =>
    {
        foreach (var fav in items)
        {
            if (fav.IsFolder)
            {
                <div class="menu-item folder-item">
                    <i class="fas fa-folder text-warning" style="margin-right:8px;"></i>
                    <span style="flex: 1">@fav.Name</span>
                    <i class="fas fa-chevron-right" style="font-size: 0.7rem; margin-left: 8px;"></i>
                    <div class="submenu">
                        @RenderFavorites(fav.Children)
                    </div>
                </div>
            }
            else
            {
                <div class="menu-item" @onclick="() => LoadFavorite(fav.Path)">
                    <i class="fas fa-star" style="margin-right:8px; color: var(--accent-color);"></i>
                    <span>@fav.Name</span>
                </div>
            }
        }
    };

    private string FormatSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private string GetIconClass(FileSystemItem item)
    {
        if (item is DirectoryItem) return "fas fa-folder text-warning"; // text-warning is usually yellow/gold if bootstrap, else we need style or custom class
        // Use inline style or custom color for now if text-warning isn't defined in my new css.
        // Wait, my new css doesn't define text-warning. I should use specific colors or "fas fa-folder" with inline style in markup?
        // Let's return class and I'll add style in markup or here.
        // Actually, let's just use "fas fa-folder" and assume I add color in markup or CSS.
        // Or I can return "fas fa-folder" and the markup has style.
        
        string ext = item.Extension.ToLower();
        return ext switch
        {
            ".exe" => "fas fa-window-maximize",
            ".dll" => "fas fa-cogs",
            ".txt" => "fas fa-file-alt",
            ".pdf" => "fas fa-file-pdf",
            ".jpg" or ".png" or ".gif" => "fas fa-file-image",
            ".zip" or ".rar" or ".7z" => "fas fa-file-archive",
            ".cs" or ".js" or ".html" or ".css" => "fas fa-file-code",
            _ => "fas fa-file"
        };
    }

    private RenderFragment RenderSortIndicator(string column) => __builder =>
    {
        if (State.SortColumn == column)
        {
            <i class='fas @(State.SortAscending ? "fa-sort-up" : "fa-sort-down")' style="margin-left: 5px; color: var(--accent-color);"></i>
        }
    };
    
    private void ShowItemContextMenu(MouseEventArgs e, FileSystemItem item)
    {
        ActivatePanel();
        if (!State.SelectedItems.Contains(item))
        {
            State.SelectItem(item);
        }

        ContextMenuItems = new List<ContextMenu.MenuAction>
        {
            new ContextMenu.MenuAction { Label = "Rename", IconClass = "fas fa-edit", Action = () => TriggerAction(ActionType.Rename) },
            new ContextMenu.MenuAction { IsSeparator = true },
            new ContextMenu.MenuAction { Label = "Copy", IconClass = "fas fa-copy", Action = () => CopyItems() },
            new ContextMenu.MenuAction { Label = "Cut", IconClass = "fas fa-cut", Action = () => CutItems() },
            new ContextMenu.MenuAction { IsSeparator = true },
            new ContextMenu.MenuAction { Label = "Delete", IconClass = "fas fa-trash", IconColor = "#ff4d4d", Action = () => DeleteItems() },
        };

        ContextMenuX = e.ClientX;
        ContextMenuY = e.ClientY;
        IsContextMenuVisible = true;
    }

    private void ShowBackgroundContextMenu(MouseEventArgs e)
    {
        ActivatePanel();
        
        var canPaste = ClipboardService.Items.Any();
        ContextMenuItems = new List<ContextMenu.MenuAction>
        {
            new ContextMenu.MenuAction { Label = "Paste", IconClass = "fas fa-paste", Disabled = !canPaste, Action = () => PasteItems() },
             new ContextMenu.MenuAction { IsSeparator = true },
            new ContextMenu.MenuAction { Label = "New Folder", IconClass = "fas fa-folder-plus", Action = () => TriggerAction(ActionType.MkDir) },
            new ContextMenu.MenuAction { Label = "New File", IconClass = "fas fa-file-medical", Action = () => TriggerAction(ActionType.NewFile) },
        };

        ContextMenuX = e.ClientX;
        ContextMenuY = e.ClientY;
        IsContextMenuVisible = true;
    }

    private void CloseContextMenu()
    {
        IsContextMenuVisible = false;
        StateHasChanged();
    }

    private void ExecuteMenuAction(ContextMenu.MenuAction action)
    {
        action.Action?.Invoke();
    }

    private void CopyItems()
    {
        ClipboardService.Copy(State.SelectedItems);
    }

    private void CutItems()
    {
        ClipboardService.Cut(State.SelectedItems);
    }

    private void DeleteItems()
    {
        // Simulate F8 key press to trigger delete logic in Home.razor
        _ = JSRuntime.InvokeVoidAsync("eval", "window.dispatchEvent(new KeyboardEvent('keydown', {'key': 'F8'}))");
    }

    private async Task PasteItems()
    {
        if (!ClipboardService.Items.Any()) return;

        var sourceItems = ClipboardService.Items;
        var isCut = ClipboardService.IsCut;
        var destPath = State.CurrentPath;

        // Perform operation
        // Logic similar to Home.razor SubmitModal for Copy/Move but automated
        
        // We need ProgressService from DI? Not injected here.
        // And FileService is here.
        
        // This logic is overlapping with Home.razor logic. 
        // Ideally should be centralized.
        // For now, let's implement basic paste here using FileService.
        
        foreach (var item in sourceItems)
        {
            var dest = System.IO.Path.Combine(destPath, item.Name);
            if (isCut)
                await FileService.MoveItemAsync(item.FullPath, dest);
            else
                await FileService.CopyItemAsync(item.FullPath, dest);
        }
        
        if (isCut) ClipboardService.Clear();
        
        await LoadData();
        // Refresh other panel? We don't have ref to other panel here. 
        // AppState change should trigger Home refresh?
        // AppState.LeftPanel.OnChange... relies on Home implementation.
        // We should notify state changed.
        State.NotifyStateChanged(); 
        
        // NOTE: If we move from other panel, we should ideally refresh that panel too.
        // But from here we only know our State.
        // Maybe we should invoke global refresh via AppState?
        // AppState doesn't have "RefreshAll".
        // But if we moved files, the other panel might show incorrect data until refreshed.
        // Just triggering AppState.OnChange might be enough if Home subscribed.
        // Home subscribes and calls StateHasChanged, but doesn't reload data automatically unless paths change.
        // We need a way to request Reload.
        // Let's leave it for now, manual refresh (F5 or navigation) might be needed for source panel.
    }

     private void TriggerAction(ActionType action)
    {
        // Map to F-Keys for Home to handle
         string key = action switch 
         {
             ActionType.Rename => "F2",
             ActionType.MkDir => "F7",
             ActionType.NewFile => "F9",
             _ => ""
         };
         if (!string.IsNullOrEmpty(key))
            _ = JSRuntime.InvokeVoidAsync("eval", $"window.dispatchEvent(new KeyboardEvent('keydown', {{'key': '{key}'}}))");
    }

    private enum ActionType { MkDir, NewFile, Rename }
}
